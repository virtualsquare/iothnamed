.\" Copyright (C) 2023 VirtualSquare. Project Leader: Renzo Davoli
.\"
.\" This is free documentation; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License,
.\" as published by the Free Software Foundation, either version 2
.\" of the License, or (at your option) any later version.
.\"
.\" The GNU General Public License's references to "object code"
.\" and "executables" are to be interpreted as the output of any
.\" document formatting or typesetting system, including
.\" intermediate and printed output.
.\"
.\" This manual is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\" GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public
.\" License along with this manual; if not, write to the Free
.\" Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
.\" MA 02110-1301 USA.
.\"
.\" Automatically generated by Pandoc 2.17.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "IOTHNAMED.CONF" "5" "July 2023" "VirtualSquare" "File Formats Manual"
.hy
.SH NAME
.PP
iothnamed.conf(5) \[en] \f[V]iothnamed\f[R](1) configuration file.
.SH DESCRIPTION
.PP
The configuration file has several sections: stack, dns, auth, static,
option
.PP
Comments can be inserted using lines beginning by #.
.SS stack section
.PP
Following the idea of Internet of Threads it is possible to specify
which stacks are used to provide the service and to forward the
requests.
Stack specifications are provided using the syntax of
\f[V]newstackc\f[R] (see \f[V]iothconf\f[R](3))
.PP
It is not possible to define a stack twice (so either \f[V]stack\f[R] or
at least one of \f[V]rstack\f[R] \f[V]fstack\f[R] can be specified.)
A stack definition can be split on several lines.
The \f[V]stack\f[R] and \f[V]vnl\f[R] options must appear in the first
line.
If a stack definition is omitted the stack provided by the kernel is
used.
.PP
e.g.:
.IP
.nf
\f[C]
rstack    stack=vdestack,vnl=vde:///tmp/hub
rstack    mac=80:01:01:01:01:01,eth
rstack    ip=192.168.1.24/24
fstack    stack=kernel
\f[R]
.fi
.SS dns section
.PP
Set the IP address/addresses of the DNS servers to forward queries when
required.
Up to three IP addresses can be listed.
.PP
e.g.:
.IP
.nf
\f[C]
dns       8.8.8.8
dns       80.80.80.80
dns      2620:119:35::35
\f[R]
.fi
.SS net section
.PP
This section assign names to ranges of addresses.
Up to 64 names can be defined.
.PP
e.g.:
.IP
.nf
\f[C]
net       world ::/0
net       local 192.168.1.0/24
net       local 10.0.10.0/24
net       local6 2001:760:2e00:ff00::/64
\f[R]
.fi
.PP
the name \f[V]world\f[R] matches any IPv6 address.
The net name \f[V]local\f[R] defines the IPv4 addresses 192.168.1.x and
10.0.10.x.
\f[V]local6\f[R] matches 2001:760:2e00:ff00::/64.
.SS auth section
.PP
This section plays a central role.
It defines which services are provided depending on the ip address of
the sender who issues the name resolution request.
.IP \[bu] 2
\f[V]auth accept\f[R] defines the address ranges allowed to use TCP
queries e.g.\ only hosts in local (192.168.1.x and 10.0.10.x in the
example above) are allowed to send TCP requests:
.IP
.nf
\f[C]
          auth      accept local
\f[R]
.fi
.IP \[bu] 2
\f[V]auth error\f[R] An error is returned when a query for a specified
name/domain is received from an address space.
e.g.\ queries for the host test.err (no heading dot) and all the
hosts/subdomain of .test.err (heading dot) return an error when the
requests come from \f[V]local\f[R], 192.168.1.x and 10.0.10.x in the
example above.
.IP
.nf
\f[C]
          auth      error local test.err
          auth      error local .test.err
\f[R]
.fi
.IP \[bu] 2
\f[V]auth static\f[R] These definitions state who is allowed to query
for static addresses.
The actual name to address or reverse mappings are defined in the
following \f[V]static\f[R] section.
Here only the access control is defined.
e.g.\ the following configuration lines permit to retrieve static
definitions of hosts in the domain .foo.bar from any IPv6 address and
from IPv4 addresses matching the \f[V]local\f[R] definition.
Moreover the reverse resolution for addresses in 10.20.30.0/24 and
2001::0/6 is permitted from any IPv6 address.
So queries like 40.30.20.10.inaddr.arpa and
\&.....0.0.0.0.0.0.0.0.0.0.0.0.0.1.0.0.2.ip6.arpa are permitted.
.IP
.nf
\f[C]
          auth      static local,world .foo.bar
          auth      static world 10.20.30.0/24
          auth      static world 2001::0/64
\f[R]
.fi
.IP \[bu] 2
\f[V]auth hash\f[R] Authorize/enable the hash based resolution.
e.g.\ The following definitions enable the resolution of hosts in the
domain .htest.v2.cs.unibo.it using the base address 2002::1 and hosts in
the domain .hash.v2.cs.unibo.it using the base address to be the address
hash.map.v2.cs.unibo.it (in this latter case the actual address is
retrieved using a dns query).
.IP
.nf
\f[C]
          auth      hash world .htest.v2.cs.unibo.it 2002::1
          auth      hash world .hash.v2.cs.unibo.it hash.map.v2.cs.unibo.it
\f[R]
.fi
.IP \[bu] 2
\f[V]hrev\f[R] Authorize/enable the reverse resolution of hash based
addresses.
e.g.\ The following definitions enable the reverse resolution for the
networks of the \f[V]auth hash\f[R] example.
.IP
.nf
\f[C]
          auth      hrev world 2002::1/64
          auth      hrev world hash.map.v2.cs.unibo.it/64
\f[R]
.fi
.IP \[bu] 2
\f[V]otip\f[R] Authorize/enable the one time ip (otip) based resolution.
The name resolution changes during the time, Only legitimate users
knowing the password can compute the current address of a server.
e.g.\ Only local queries can have the current address computed using the
password \f[V]pwd\f[R]:
.IP
.nf
\f[C]
          auth      otip local .otip.v2.cs.unibo.it 2003::1 pwd
\f[R]
.fi
.IP \[bu] 2
\f[V]cache\f[R] Define which addresses can retrieve cached record.
e.g.\ queries coming from addresses in \f[V]local\f[R] can retrieve data
for any domain (.):
.IP
.nf
\f[C]
          auth      cache local .
\f[R]
.fi
.IP \[bu] 2
\f[V]fwd\f[R] Define which queries can be fowarded depending on the
address of the querier: e.g.\ queries coming from addresses in
\f[V]local\f[R] can be forwarded.
.IP
.nf
\f[C]
          auth      fwd local .
\f[R]
.fi
.SS static section
.PP
This section permits to define static mappings.
.PP
e.g.:
.IP
.nf
\f[C]
static    A    test.foo.bar 10.20.30.40
static    AAAA test.foo.bar 2001::1
static    PTR  10.20.30.40 test.foo.bar
static    PTR  2001::1 test.foo.bar
static    CNAME  tost.foo.bar test.foo.bar
static    NS  dom.foo.bar dns.foo.bar
static    MX  test.foo.bar 10 mail.foo.bar
static    TXT  test.foo.bar \[dq]sempre caro mi fu quest\[aq]ermo colle\[dq] \[dq]long string\[dq]
\f[R]
.fi
.PP
Note that PTR records use the convenient numeric address encoding as a
shortcut for names ot the type \&....inaddr.arpa or \&....ip6.arpa.
.SS option section
.IP \[bu] 2
\f[V]option hrevmode\f[R] defines the policy to store the reverse
mapping for hash resolutions.
There are four supported choices: \f[V]always\f[R] (the result of any
hash resolution is stored for the later reverse resolution),
\f[V]net\f[R] (store the mapping for queries coming from the same /64
network), \f[V]same\f[R] (store the mapping ony when the requst comes
from the same address, the node is askign for its own address),
\f[V]never\f[R].
.IP \[bu] 2
\f[V]option hashttl\f[R] defines the ttl value for hash generated
addresses.
.IP \[bu] 2
\f[V]option tcplistenbacklog\f[R] defines the backlog queue length for
the tcp connection requests (it is the argument of listen(2)).
.IP \[bu] 2
\f[V]option tcptimeout\f[R] defines the timeout in seconds to drop idle
tcp connections.
.SH EXAMPLES
.SS static local names + proxy + cache
.PP
The following configuration file named \f[V]local+forward.rc\f[R] sets
up the\f[V]iothnamed\f[R] dns server to run as a caching proxy for local
clients.
The server also defines some local names for direct and reverse
resolution.
.IP
.nf
\f[C]
# The service is provided for queriers reaching this server on the
# vde network vde:///tmp/hub, IP address 192.168.1.24.
rstack    stack=vdestack,vnl=vde:///tmp/hub
rstack    mac=80:01:01:01:01:01,eth
rstack    ip=192.168.1.24/24
# The kernel stack is used to forward requests to remote dns servers
fstack    stack=kernel

# forward requests using IPv4 packets to 8.8.8.8 or 80.80.80.80
dns       8.8.8.8
dns       80.80.80.80

# the net name \[aq]local\[aq] defines the ip range 192.168.1.0/24
net       local 192.168.1.0/24

# clients from \[aq]local\[aq] are allowed to send tcp dns requests
auth      accept local
# clients from \[aq]local\[aq] can receive replies for names xxxx.test.local
auth      static local .test.local
# clients from \[aq]local\[aq] can receive replies for names 1.168.192.in-addr.arpa
auth      static local 192.168.1.0/24
# search in the cache (forwarded query results are cached)
auth      cache local .
# requests from \[aq]local\[aq] can be forwarded
auth      fwd local .


# static definitions
static    A one.test.local 192.168.1.1
static    A two.test.local 192.168.1.2
# static definitions for reverse resolution
static    PTR 192.168.1.1 one.test.local
static    PTR 192.168.1.2 two.test.local
\f[R]
.fi
.PP
In order to test this configuration start the vde network, e.g.:
.IP
.nf
\f[C]
vde_plug null:// hub:///tmp/hub
\f[R]
.fi
.PP
in another terminal window run the iothnamed server:
.IP
.nf
\f[C]
iothnamed local+forward.rc
\f[R]
.fi
.PP
in a third terminal window start a vdens and configure it:
.IP
.nf
\f[C]
vdens -R 192.168.1.24 vde:///tmp/hub
ip addr add 192.168.1.1/24 dev vde0
ip link set vde0 up
ip link set lo up
\f[R]
.fi
.PP
Now in the vdens it is possible to query the iothnamed server using
\f[V]host\f[R] or \f[V]dig\f[R].
it is also possible to use iothnamed to run network clients and servers.
.IP
.nf
\f[C]
$ host prep.ai.mit.edu
prep.ai.mit.edu is an alias for ftp.gnu.org.
ftp.gnu.org has address 209.51.188.20
ftp.gnu.org has IPv6 address 2001:470:142:3::b
$ ping one.test.local
PING one.test.local (192.168.1.1) 56(84) bytes of data.
64 bytes from one.test.local (192.168.1.1): icmp_seq=1 ttl=64 time=0.038 ms
64 bytes from one.test.local (192.168.1.1): icmp_seq=2 ttl=64 time=0.061 ms
\f[R]
.fi
.SS delegated subdomain
.PP
In this example the domain dom.v2.cs.unibo.it has been delegated to the
public IP addresses 130.136.31.250 and 2001:760:2e00:ff00::fd
.PP
(in order to test this example on your environment, IP addresses and
domain names should be modified to be consistent with your scenario)
.PP
Here is the \f[V]delegated.rc\f[R] configuration file.
.IP
.nf
\f[C]
# the name \[aq]world\[aq] matches any IPv6 or IPv4 address.
net       world ::/0

# the static definition for names xxxx.dom.v2.cs.unibo.it
# are available for everybody
auth      static world .dom.v2.cs.unibo.it

static    A one.dom.v2.cs.unibo.it 192.168.1.1
static    AAAA one.dom.v2.cs.unibo.it fc00::1
static    A two.dom.v2.cs.unibo.it 192.168.1.2
static    AAAA two.dom.v2.cs.unibo.it fc00::2
\f[R]
.fi
.PP
Run \f[V]iothnamed\f[R] on a host/namespace which owns the IP addresses
used in the subdomain delegation:
.IP
.nf
\f[C]
# ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: vde0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UNKNOWN group default qlen 1000
    link/ether f2:09:f8:ff:cb:f4 brd ff:ff:ff:ff:ff:ff
    inet 130.136.31.250/24 scope global vde0
       valid_lft forever preferred_lft forever
    inet6 2001:760:2e00:ff00::fd/64 scope global
       valid_lft forever preferred_lft forever
    inet6 2001:760:2e00:ff00:f009:f8ff:feff:cbf4/64 scope global dynamic mngtmpaddr
       valid_lft 86331sec preferred_lft 14331sec
    inet6 fe80::f009:f8ff:feff:cbf4/64 scope link
       valid_lft forever preferred_lft forever
# ip route
default via 130.136.31.1 dev vde0
130.136.31.0/24 dev vde0 proto kernel scope link src 130.136.31.250
# ip -f inet6 route
2001:760:2e00:ff00::/64 dev vde0 proto kernel metric 256 expires 86397sec pref medium
fe80::/64 dev vde0 proto kernel metric 256 pref medium
default via fe80::2851:20ff:fe4b:b7a5 dev vde0 proto ra metric 1024 expires 297sec hoplimit 64 pref medium
# iothnamed delegated.rc
\f[R]
.fi
.PP
From a random host connected to the Internet:
.IP
.nf
\f[C]
$ host one.dom.v2.cs.unibo.it
one.dom.v2.cs.unibo.it has address 192.168.1.1
one.dom.v2.cs.unibo.it has IPv6 address fc00::1
\f[R]
.fi
.PP
\f[V]iothnamed\f[R] can also run as a \f[I]internet of threads\f[R]
process (instead of a real host or a namespace).
Just prepend in the configuration file the definition of rstack:
.IP
.nf
\f[C]
rstack    stack=vdestack,vnl=vde:///tmp/hub
rstack    mac=80:01:01:01:01:01,eth
rstack    ip=130.136.31.250/24,gw=130.136.31.1
rstack    ip=2001:760:2e00:ff00::fd/64,ip=2001:760:2e00:ff00::ff/64
\f[R]
.fi
.SS hash based IPv6 addresses (for local addresses)
.PP
Here is the localhash+forward.rc configuration file:
.IP
.nf
\f[C]
rstack    stack=vdestack,vnl=vde:///tmp/hub
rstack    mac=80:01:01:01:01:01,eth
rstack    ip=192.168.1.24/24
rstack    ip=fc00::24/64
fstack    stack=kernel

dns       8.8.8.8
dns       80.80.80.80

net       local 192.168.1.0/24
net       local fc00::/64
auth      accept local

# define the base address as a static record
auth      static local hash.local
static    AAAA hash.local fc00::

auth      hash local .hash.local hash.local
auth      hrev local hash.local/64

# alt. without static definition of the base addr:
# auth      hash local .hash.local fc00::
# auth      hrev local fc00::/64

auth      cache local .
auth      fwd local .

option hrevmode always
\f[R]
.fi
.PP
Start the \f[V]iothnamed\f[R] server:
.IP
.nf
\f[C]
iothnamed localhash+forward.rc
\f[R]
.fi
.PP
Start a vdens and configure it to perform some tests:
.IP
.nf
\f[C]
$ vdens -R fc00::24 vde:///tmp/hub
$ ip addr add fc00::1/64 dev vde0
$ ip link set vde0 up
$ ip link set lo up
$ host renzo.hash.local
renzo.hash.local has IPv6 address fc00::4cc:8049:6765:d03a
$ host hic_sunt_leones.hash.local
hic_sunt_leones.hash.local has IPv6 address fc00::9c8f:74b4:705f:6512
$ host fc00::9c8f:74b4:705f:6512
2.1.5.6.f.5.0.7.4.b.4.7.f.8.c.9.0.0.0.0.0.0.0.0.0.0.0.0.0.0.c.f.ip6.arpa domain name pointer hic_sunt_leones.hash.local.
\f[R]
.fi
.PP
Any name having a \f[V].hash.local\f[R] suffix is resolved as a hash
based address.
In order to define a new network node (host, namespace or process) just
decide its name and assign it the correspondent IPv6 hash computed
address.
The name resolution process will work without any specific
configuration.
.SS hash based IPv6 addresses (with delegation)
.PP
The scenario is the combination of the two previous examples.
In this case the domain hash.v2.cs.unibo.it has been delegated to
2001:760:2e00:ff00::fd and 130.136.31.253, while the reverse resolution
of 2001:760:2e00:ff00::/64 has been delegated to 2001:760:2e00:ff00::ff.
.PP
Here is the \f[V]delegated+hash.rc\f[R] file:
.IP
.nf
\f[C]
net       world ::/0

# define glue record (for base address)
auth      static world hash.v2.cs.unibo.it
static    AAAA hash.v2.cs.unibo.it 2001:760:2e00:ff00::

auth      hash world .hash.v2.cs.unibo.it hash.v2.cs.unibo.it
auth      hrev world hash.v2.cs.unibo.it/64

option hrevmode always
\f[R]
.fi
.PP
Start \f[V]iothnamed\f[R] in a properly configured host/namespace:
.IP
.nf
\f[C]
# ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: vde0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UNKNOWN group default qlen 1000
    link/ether 46:9f:c6:9c:8b:6a brd ff:ff:ff:ff:ff:ff
    inet 130.136.31.253/24 scope global vde0
       valid_lft forever preferred_lft forever
    inet6 2001:760:2e00:ff00::ff/64 scope global
       valid_lft forever preferred_lft forever
    inet6 2001:760:2e00:ff00::fd/64 scope global
       valid_lft forever preferred_lft forever
    inet6 fe80::449f:c6ff:fe9c:8b6a/64 scope link
       valid_lft forever preferred_lft forever
# iothnamed delegated+hash.rc
\f[R]
.fi
.PP
Now from a random host on the internet if is possible to query for any
name \f[V]something.hash.v2.cs.unibo.it\f[R], e.g.
.IP
.nf
\f[C]
$ host renzo.hash.v2.cs.unibo.it
renzo.hash.v2.cs.unibo.it has IPv6 address 2001:760:2e00:ff00:6066:4f84:db3e:c9cb
$ host lucia.hash.v2.cs.unibo.it
lucia.hash.v2.cs.unibo.it has IPv6 address 2001:760:2e00:ff00:cf1:1fe9:aad4:e838
$ host whatever-you-want.hash.v2.cs.unibo.it
whatever-you-want.hash.v2.cs.unibo.it has IPv6 address 2001:760:2e00:ff00:542d:ffcb:17e:8fa7
\f[R]
.fi
.PP
The reverse resolution is also available (provided it queries for an
address of a name already queried in the past):
.IP
.nf
\f[C]
$ host 2001:760:2e00:ff00:542d:ffcb:17e:8fa7
7.a.f.8.e.7.1.0.b.c.f.f.d.2.4.5.0.0.f.f.0.0.e.2.0.6.7.0.1.0.0.2.ip6.arpa domain name pointer whatever-you-want.hash.v2.cs.unibo.it.
\f[R]
.fi
.SS OTIP (one time IP) and forward.
.PP
This configuration can be used to provide access to otip protected
services.
Domain names like \f[V]renzo.otip\f[R] or \f[V]anything.otip\f[R] are
translated to the current IP address of the service.
(These addresses change after 32 secs).
.PP
This is the \f[V]otip+forward.rc\f[R] file:
.IP
.nf
\f[C]
rstack    stack=vdestack,vnl=vde:///tmp/hub
rstack    mac=80:01:01:01:01:01,eth
rstack    ip=192.168.1.24/24
rstack    ip=fc00::24/64
fstack    stack=kernel

dns       8.8.8.8
dns       80.80.80.80

net       local 192.168.1.0/24
net       local fc00::/64
auth      accept local

auth      otip local .otip 2001:760:2e00:ff00:: mypassword

auth      cache local .
auth      fwd local .
\f[R]
.fi
.PP
Let us test the configuration.
.PP
Start the \f[V]iothnamed\f[R] server:
.IP
.nf
\f[C]
iothnamed otip+forward.rc
\f[R]
.fi
.PP
Start and configure a vdens session (e.g.\ VNL=vde:///tmp/hub, ip addr
fc00::1/64, dns=fc00::24).
In this vdens session:
.IP
.nf
\f[C]
$ host renzo.otip
renzo.otip has IPv6 address 2001:760:2e00:ff00:e8be:1b1f:6545:8d12
\f[R]
.fi
.PP
wait 32 secs or more
.IP
.nf
\f[C]
$ host renzo.otip
renzo.otip has IPv6 address 2001:760:2e00:ff00:64c6:30b9:3f3a:14d7
\f[R]
.fi
.SH SEE ALSO
.PP
iothnamed(1)
.SH AUTHOR
.PP
VirtualSquare.
Project leader: Renzo Davoli.
